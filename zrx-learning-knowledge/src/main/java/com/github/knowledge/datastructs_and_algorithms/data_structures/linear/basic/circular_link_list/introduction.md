循环链表(也叫循环线性表)
==================================
循环链表，也叫循环线性表，其存储结构基本同单向链表。它是在单向链表的基础上加以改进形成的。可以解决单向链表的单方向查找的缺点。因为单向链表只能单方向而不能反方向查找，并且最后一个节点指针域的值是null,为了解决单向链表的缺点，可以利用末尾节点的空指针完成向前查找。单向链表的末尾节点的指针域的null变为指向第一个节点，逻辑上形成一个环型，该存储结构称为单向循环链表。
</br>
附图：
</br>
循环链表相对单向链表而言，其优点是在不增加任何空间的情况下，能够已知任意结点的地址，可以快速找到链表中的所有结点（环向查找）。</br>
当然，循环线性链表中已知道链表中的任何节点，可以找到链表中所有结点（循环找），我们一般还是习惯把头结点作为已知条件，但是如果已知条件是头节点，将在一下的插入或删除结点时造成不便：
- 删除末尾结点（查找要花很长,时间复杂度为O(n)）。
- 在第一个结点前插入新的结点（循环链表要找到末尾结点才能操作,时间复杂度为O(n)）。

以上的两种情况会造成无谓的时间开销，为了解决这个问题，通常在循环链表的末尾结点是<Strong>已知条件</Strong>,这样以上的两种情况都可以直接完成，因为已知末尾结点可以直接找到头结点，此时，时间复杂度为O(1),这样在不增加任何开销的情况下，减小了时间的开销。</br>
空的循环线性链表根据定义可以与单向链表相同，也可以不相同。判断循环链表的末尾结点条件也就不同于单向链表，不同之处在于单向链表是判断最后结点的指针域是否为null,而循环线性链表末尾结点的判断条件是其指针域的值指向头结点。</br>
循环链表的插入，删除运算基本同单向链表，只是查找时判别条件不同而已。但是这种循环链表的危险之处在于：<Strong>链表没有明显的尾端，可能使算法进入死循环，所以，判断条件应该用curr.next()!=head 替换 单向链表的curr.next()!=null</Strong>.
</br></br>
> 注：java自带的集合包中有实现双向链表，路径是:java.util.LinkedList.</br>
双端链表： 有两个变量分别记录头结点和尾结点</br>
双向链表：中每个结点连接它的前一个和后一个结点


